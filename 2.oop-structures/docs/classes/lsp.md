# Принцип подстановки Лисков

**Функции, которые используют базовый тип,
должны иметь возможность использовать подтипы базового типа, не зная об этом**

Класс-наследник может изменить поведение любого метода настолько, насколько это вообще возможно. Эти изменения могут за
собой повлечь серьезные архитектурные проблемы.

Например, есть логгер

```ts
// Определение
class Logger {
  // Код
}

// Использование
const logger = new Logger()
logger.log('debug', 'Doing work')
logger.log('info', 'Useful for debugging')
```

Сигнатура метода `log` первым параметром принимает уровень сообщения, а вторым сообщение.

Предположим, мы решили изменить сигнатуру так, чтобы уровень передавался вторым параметром.

```ts
class MyLogger extends Logger {
  // Тут реализуем новую сигнатуру log
  log(message, level = 'debug') {
    return super.log(level, message)
  }
}

// Использование
logger.log('Doing work') // По умолчанию debug
logger.log('Useful for debugging', 'info')
```

Подобное изменение сигнатуры делает невозможным полиморфизм. Эти классы несовместимы между собой.

```ts
// Предположим, что какой-то компонент системы хочет работать с логгером Logger, но внутрь передается MyLogger
const logger = new MyLogger()
database.setLogger(logger)

database.doSomething()
// Внутри вызывается логгер
// logger.log('info', 'boom!');
```

## Правила проектирования иерархий типов

Существует несколько правил, которые надо учитывать при работе с типами:

* Предусловия не могут быть усилены в подклассе
* Постусловия не могут быть ослаблены в подклассе
* Исторические ограничения

Предусловия - ограничения на входные данные, а постусловия - на выходные