# Hexlet course

Метод `Object.assign()` берёт объект, переданный первым параметром, и переносит в него всё из объектов, переданных остальными параметрами. В нашей ситуации это один объект, переданный вторым параметром.
У метода `Object.assign()` есть одно ограничение: он выполняет только поверхностное слияние. Вложенные объекты не сравниваются, а просто заменяются

В JavaScript клонирование можно эмулировать с помощью `Object.assign()`. Для этого нужно первым параметром передать пустой объект, а вторым — тот, который нужно клонировать:

## Хеш-таблицы

Хеширование — операция, которая преобразует любые входные данные в строку (реже число) фиксированной длины.
Функция, реализующая алгоритм преобразования, называется «хеш-функцией», а результат называют «хешем» или «хеш-суммой».
Наиболее известны CRC32, MD5 и SHA (много разновидностей).

```ts
// В JavaScript нет встроенной поддержки алгоритма хеширования crc32 (удобен для наглядности)
// Поэтому используется сторонняя библиотека
import crc32 from "crc-32";

const data = "Hello, world!"; // Любые данные, которые мы хотим хешировать
const hash = crc32.str(data);

// Хеш всегда одинаковый для одних и тех же данных!
console.log(hash); // => -337197338
```

После того, как хеш получен, его можно преобразовать в индекс массива, например, через получение остатка от деления:

```ts
// Это делается для того, чтобы индексы не были слишком большими
// Чем больше размер массива, тем больше памяти он занимает
const index = Math.abs(hash) % 1000; // по модулю
console.log(index); // => 338
```

Рассмотрим процесс добавления нового значения в ассоциативный массив (напоминаем, что в JavaScript он представлен типом данных Object). Программист пишет:

```ts
const data = {};
data["key"] = "value";
```

```ts
// Для простоты показано на JavaScript, хотя в реальности всё это происходит на более низком уровне

// 1. Создание ассоциативного массива приводит к инициализации индексированного массива внутри интерпретатора.
const internal = [];
// Во время присвоения значения `data['key'] = 'value'`, интерпретатор выполняет несколько действий:

// 2. Хеширует ключ. Результатом хеширования становится число.
const hash = crc32.str("key");
// 3. Число, полученное на предыдущем шаге, преобразуется в индекс массива.
const index = Math.abs(hash) % 1000;
// В значение внутреннего индексированного массива, по найденному индексу, записывается еще один массив,
// первым элементом которого становится ключ `'key'`, а вторым значение `'value'`.
internal[index] = ["key", "value"];
```
