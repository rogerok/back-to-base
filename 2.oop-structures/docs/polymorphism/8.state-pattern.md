# Паттерн Состояние

Паттерн "Состояние" - явный пример полиморфизма подтипов, с помощью которого можно избавиться от условных конструкций.

Смоделируем класс телефона, с тремя базовыми состояниями

Всего у телефона три базовых состояния:

1. Телефон выключен. Экран не реагирует на прикосновения.
2. Телефон включен, но экран выключен. Экран реагирует только на прикосновение (но не на смахивание) и включается.
3. Телефон включен и экран тоже. Реакция на прикосновения и жесты зависит от активного приложения.

Смоделируем эту логику в классе, отвечающем за экран, и добавим туда два события: прикосновение (touch) и смахивание (swipe).

```ts
class MobileScreen {
  constructor() {
    // В самом начале телефон выключен
    this.powerOn = false;
    this.screenOn = false;
  }

  // Включение питания
  powerOn() {
    this.powerOn = true;
  }

  // Прикосновение
  touch() {
    // Если питание выключено, то ничего не происходит
    if (!this.powerOn) {
      return;
    }

    // Если экран был выключен, то его надо включить
    if (!this.screenOn) {
      this.screenOn = true;
    }

    // На событие должно реагировать текущее активное приложение
    this.notify("touch");
  }

  // Смахивание
  swipe() {
    // Если выключено питание или экран, то ничего не происходит
    if (!this.powerOn || !this.screenOn) {
      return;
    }

    // На событие должно реагировать текущее активное приложение
    this.notify("swipe");
  }
}
```

В данном коде уже несколько условных конструкций.

Выделить явное состояние, можно с помощью флагов (чаще всего это антипаттерн)

```ts
constructor() {
  this.powerOn = false;
  this.screenOn = false;
}
if (!this.powerOn || !this.screenOn) {
  return
}
```

Следующий шаг заменить флаги на одну переменную

```ts
type State = "powerOff" | "screenDisabled" | "screenOn";
class MobileScreen {
  constructor() {
    this.stateName = "powerOff";
  }
}
```

## Классы Состояний

Для избавления от условных конструкций понадобится полиморфизм

Благодаря наличию явно выделенного состояния легко увидеть зависимость поведения от состояния. Именно состояния должны трансформироваться в классы со своим собственным поведением, специфичным для данного состояния.

```ts
import PowerOffState from "./states/PowerOffState.js";
import ScreenDisabledState from "./states/ScreenDisabledState.js";
import ScreenOnState from "./states/ScreenOnState.js";

class MobileScreen {
  constructor() {
    // Список состояний нужен для переключений между ними
    // Иначе возможно появление циклических зависимостей внутри состояний
    this.states = {
      powerOff: PowerOffState,
      screenDisabled: ScreenDisabledState,
      screenOn: ScreenOnState,
    };
    // Начальное состояние
    // Внутрь передается текущий объект
    // Это нужно для смены состояний (примеры ниже)
    this.state = new this.states.powerOff(this);
  }

  powerOn() {
    // Предыдущее состояние нас не волнует
    // Все данные хранятся в самом экране
    // Объекты-состояния не имеют своих данных
    this.state = new this.states.screenDisabled(this);
  }

  touch() {
    this.state.touch();
  }

  swipe() {
    this.state.swipe();
  }
}

// Обратите внимание что с точки зрения внешнего кода (пользователя экрана)
// ничего не изменилось.
```
