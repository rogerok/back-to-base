# Стратегия

Задача стратегии подменять алгоритм во время выполнения.
Полиморфизм используется для **динамического выбора поведения**.

Структура:

- `Strategy` — интерфейс

- `ConcreteStrategyA/B` — реализации

- `Context` — делегирует выполнение стратегии

Ключевое:

- Полиморфизм по алгоритму

- Подмена возможна во время выполнения

- Фокус на поведении

# Фабрика

Задача фабрики скрыть логику создания объектов.
Полиморфизм используется _для делегирования выбора конкретного типа_

Структура:

- `Product` — интерфейс

- `ConcreteProductA/B`

- `Factory` — решает, какой объект создать

## Пример

Сценарий

Есть интернет-магазин.
Нужно:

Создавать нужный способ оплаты (карта, PayPal, крипта).

Позволить менять способ расчёта комиссии.

### Factory — выбирает тип платёжного метода

Интерфейс продукта

```ts
interface PaymentMethod {
  pay(amount: number): void;
}
```

Конкретные реализации

- CardPayment

- PayPalPayment

- CryptoPayment

```ts
class PaymentFactory {
  static create(type: string): PaymentMethod {
    // решает какой конкретный класс вернуть
  }
}
```

Что происходит с полиморфизмом?

Фабрика возвращает один общий тип (`PaymentMethod`),
но реальный объект может быть разным.

Полиморфизм используется для сокрытия конкретного типа.

Клиенту всё равно, какой класс создан — он работает через интерфейс.

### Strategy — меняет алгоритм комиссии

Интерфейс стратегии

```ts
interface FeeStrategy {
  calculate(amount: number): number;
}
```

Реализации

- NoFee

- PercentageFee

- FixedFee

```ts
class CardPayment implements PaymentMethod {
  constructor(private feeStrategy: FeeStrategy) {}

  pay(amount: number) {
    const fee = this.feeStrategy.calculate(amount);
    // логика оплаты
  }
}
```
