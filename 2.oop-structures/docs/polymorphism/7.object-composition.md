# Объектная композиция и полиморфизм

## 1. Проблема

Есть задача: выводить приветствие пользователю в зависимости от возраста.

- < 18 → `Hi {firstName}`
- ≥ 18 → `Hello {appeal} {lastName}`

Решение через `if` — простое и корректное.  
Но цель урока — показать применение полиморфизма в классовой модели.

---

## 2. Неправильный путь — наследование (подтипы пользователя)

Идея:

- `Under18 extends User`
- `Above18 extends User`
- В каждом классе свой `getMessage()`

### Почему это плохо?

1. Возраст — не сущность предметной области, а условие отображения.
2. При добавлении новых критериев (пол, 65+, регион и т.д.):

- начинается комбинаторный взрыв классов
- появляются классы вида:
  - GirlUnder18
  - BoyUnder18
  - WomanAbove18
  - и т.д.

3. Пользователь начинает обрастать логикой интерфейса.
4. Возникает риск появления "божественного объекта".

### Ключевая ошибка:

Смешение:

- бизнес-логики (User)
- логики отображения (Greeting)

---

## 3. Правильный подход — композиция

Разделяем ответственность.

### User

- Абстракция данных
- Имеет состояние
- Имеет жизненный цикл

### Greeting

- Поведение
- Без состояния
- Нужен только для полиморфизма

---

## 4. Реализация через композицию

Создаём отдельные классы поведения:

- `GreetingForUnder18`
- `GreetingForAbove18`

```ts
class GreetingForUnder18 {
  getMessage(user) {
    return `Hi ${user.firstName}`;
  }
}

class GreetingForAbove18 {
  getMessage(user) {
    return `Hello ${user.appeal} ${user.lastName}`;
  }
}
```

Пользователь передаётся в метод, а не в конструктор.

### Почему?

Greeting — не абстракция данных.  
Это операция без состояния.  
Объект существует только ради полиморфизма.

---

## 5. Выбор нужной реализации

Создаётся фабрика:

```ts
const buildGreetingObject = (user) => {
  if (user.getAge() < 18) {
    return new GreetingForUnder18();
  } else {
    return new GreetingForAbove18();
  }
};
```

Фабрика:

- анализирует пользователя
- возвращает нужный объект Greeting

---

## 6. Что мы получили

- User остаётся чистой моделью домена.
- Логика отображения вынесена отдельно.
- При добавлении новых вариантов приветствия:
  - создаются новые классы
  - User не меняется

---

## 7. Архитектурный смысл

Это:

- композиция вместо наследования
- разделение ответственности
- предотвращение божественного объекта
- соблюдение SRP
- соблюдение OCP

---

## 8. Связь со стратегией

Фактически это паттерн Strategy:

- Greeting — интерфейс стратегии
- Конкретные Greeting-классы — реализации
- Фабрика выбирает стратегию
- Клиент использует полиморфный интерфейс

---

## 9. Итоговая модель

- Количество классов = количество вариантов поведения.
- Большинство таких классов:
  - маленькие
  - без состояния
  - существуют ради полиморфизма
- Пользователь остаётся независимым от UI-логики.

---

## Главная мысль

Если поведение не является сущностью предметной области —
его не нужно встраивать в доменную модель через наследование.

Поведение следует выносить в отдельные объекты
и связывать через композицию.
