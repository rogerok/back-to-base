CustomPromise.js
В данном испытании вы реализуете собственную версию объекта Promise.

Реализуйте в классе CustomPromise конструктор, принимающий колбек executor(resolve, reject) и метод then(onFulfill, onReject). Задачи resolve(data) и reject(error) должны выполняться асинхронно.

Алгоритм
Чтобы запускать реакции, накопленные по соответствующему состоянию промиса, сам объект с состояниями можно реализовать внутри конструктора.

В решении должны отсутствовать встроенные Promise и ключевое слово async. Только таймеры и вызовы функций из функций.

Метод catch в данной практике реализовывать не нужно, пусть всё попадает в then.

Примеры использования

```ts
import CustomPromise from "../CustomPromise.js";

const promise = new CustomPromise((resolve, reject) => reject("Hello, world!"));
promise.then((value) => {
  console.log(value); // Данный обработчик будет пропущен
});

// для упрощения решения данные из reject передавайте в resolve
const result = await promise.then((x) => x.toUpperCase());
console.log(result); // 'HELLO, WORLD!'
```

Подсказки
Изучите кейсы использования в тестах, они опираются на возможности промисов из документации.

Если почувствуете, что нужны дополнительные материалы:

курс "Синхронная асинхронность", чуть глубже погружающий в тему
курс "Автоматное программирование" о конечных автоматах, чем является промис
